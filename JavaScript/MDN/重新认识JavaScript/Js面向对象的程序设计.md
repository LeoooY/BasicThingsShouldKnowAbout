### 属性的类型
- 值属性
- 访问器属性
- 定义属性的特性
  - 
  - Object.defineProperty()
  - Object.definrProperties()

### 创建对象
工厂模式

##### 构造函数模式

实例的`constructor属性`指向构造函数

- 构造函数的使用
  - 当作构造函数使用
  - 作为普通函数调用
  - 在另一个对象的作用域中调用 call() bind apply()

- 构造函数的问题

##### 原型模式
我们创建的每个函数都有一个`prototype(原型)`属性，这个属性是一个指针，指向一个对象。

而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。

- 原型.prototype.isprototypeOf(实例对象)
- Object.getPrototypeOf(实例对象)
- 实例对象.hasOwenProperty(属性或方法)
- 属性 in 实例对象
  - 只要在实例对象中可以访问到属性就返回true
  - 所以 通过hasOwnProperty和in可以判断是否是实例属性还是原型中的属性
- Object.keys() Object.getOwnPropertyNames()
  
原型模式存在的问题：
- 当共享的数据类型存在引用类型时
  - 修改一个实例对象的`引用类型`值会影响到其他所有实例对象
  - 对于原始类型也没什么问题

可是实例一般都是要有属于自己的属性的。`这也是很少有人单独使用原型模式的原因`

##### 组合使用构造函数模式和原型模式
私有的属性和方法写到构造函数中
共享的属性和方法 写到原型中(prototype)

##### 动态原型模式

##### 寄生构造函数模式

### 继承
父类(){

}

子类(){

}

子类.prototype=new 父类()


本质是重写原型对象，代之为新类型的实例（父类的实例）。
换句话说，原来存在于`父类`的属性和方法现在也存在于`子类的prototype`里面了。 
#### 原型链继承
#### 借助构造函数继承
在子类构造函数调用超类构造函数(call、apply)
#### 组合继承（原型链和构造函数）