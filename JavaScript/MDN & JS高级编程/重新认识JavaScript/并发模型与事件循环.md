[并发模型与事件循环 | MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop#%E6%89%A7%E8%A1%8C%E8%87%B3%E5%AE%8C%E6%88%90)
[异步操作概述 | 阮一峰](https://wangdoc.com/javascript/async/general.html)
Javascript的并发模型基于“事件循环”

Runtime概念

# 异步操作概述 | 阮一峰

### 单线程模型
单线程模型指的是，JavaScript只在一个线程上运行。也就是说，JavaScript同时只能执行一个任务，其他任务都必须得在后面排队等待。

而JavaScript引擎有多个线程，只是单个Js脚本只能在一个线程上运行（称为主线程），其他线程都在后台配合

为了避免复杂性，javaScript一开始设计就是单线程，这已经成为JS的核心特性。

好处是：相对比较简单，执行环境相对单纯。
坏处是：只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。

> 常见的浏览器无响应（假死），往往就是因为某一段Js代码长时间运行（比如死循环），导致页面卡在这个地方，其他任务无法执行.Js语言本身不慢，慢的是读写外部数据，比如等待Ajax请求返回结果。这个时候，如果对方服务器迟迟没有响应，或者网络不通畅，就会导致脚本长时间停滞。


解决这个情况的是Js的`事件循环机制`.
单线程模型虽然对Js构成了很大的限制，但如果用的好，Js是不会出现阻塞的（Node可以使用很少的资源，应付高并发）

另外H5提供了Web Worker，允许Js创建子线程（但子线程限制于主线程控制且不得操作DOM，所以没有改变Js单线程的本质）

### 同步任务和异步任务
同步任务是没有被挂起，主线程上执行的任务，逐行执行，一个任务执行完才可以执行下一个

异步任务是被引擎挂起，不进入主线程，而进入任务队列的任务

### 任务队列和事件循环
主线程会逐行执行`同步任务`，遇到异步任务即加入`任务队列`，等待同步任务全部完成，开始执行任务队列的`异步任务`，将异步任务依次注如主线程执行，直到`任务队列清空`


Js会一遍一遍循环检测异步任务是否可以进入主线程，这种机制成为`事件循环`


### 异步操作的模式
- 回调函数
  - 优点：简单，容易理解
  - 缺点：高耦合，不利于代码的阅读和维护，结构混乱，流程难以追踪，且每个任务只能指定一个回调函数
  
- 事件监听
另一种思路是采用事件驱动模式。异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生。

  - 优点：比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，可以去耦合，有利于实现模块化
  - 缺点：整个程序都要变成事件驱动模型，运行流程会变得很不清晰。阅读代码的时候，很难看出主流程。

- 发布/订阅（观察者模式）
事件完全可以理解成“信号” ，如果存在一个信号中心，某个任务执行完成，就向信号中心“发布”一个信号，其他任务可以向信号中心“订阅”这个信号，从而知道什么时候自己可以开始执行，这就叫做“发布/订阅者”模式，也叫观察者模式
  - 这种方法的性质类似于“事件监听” ，但明显优于“事件监听”。因为可以通过查看“消息中心”，了解存在多少信号，每个信号有多少订阅者，从而监控程序的运行。

### 异步操作的流程控制
- 串行执行
- 并行执行
- 并行和串行结合


# 定时器 | 阮一峰
JS提供定时执行代码的函数`setTimeout`和`setInterval`
（它们是异步的）

### setTimeout()
setTimeout函数用来指定某个函数或者代码，在多少毫秒之后执行。

会返回一个整数，表示定时器的编号。

### setInterval()
setInterval指定的是每次执行的间隔，并不会考虑每次任务的执行时间


为了确保两次执行之间有固定的间隔，可以使用setTimeout,指定下一次执行的具体时间。


### 运行机制
setTimeout和setInterval的运行机制，是将指定的代码移出本轮事件循环，等到下一轮事件循环，再检查是否到了指定事件。

所以两个函数都是等待同步任务执行完毕才开始计时的，而同步任务的执行时间长短是不确定的，所以没法保证这两个函数一定会按照预定时间执行。

# Promise对象 | 阮一峰
Promise对象是Js的异步操作解决方案，为异步操作提供统一接口。

它起到代理作用（proxy），充当异步操作与回调函数之间的中介，
使得异步操作具备t同步操作的接口。

Promise可以让异步操作写起来，就像在写同步操作一样，而不必嵌套回调函数。

- Promise是一个对象，也是一个构造函数
```JavaScript
function f1(){
  //异步代码......
}

var p=new Promise(f1);

p.then(f2);
```
`Promise`构造函数接受一个回调函数`f1`作为参数，`f1`函数内是异步操作代码。返回的p是一个Promise实例对象。`f1`的异步操作完成，就会执行`f2`。

Promise的设计思想是，所有异步任务都返回一个Promise实例对象。
Promise有then方法，用来指定下一步的回调函数。
>传统的写法可能需要把f2作为回调函数传入f1，比如写成`f1(f2)`,异步操作完成后在f1内部调用f2
promise使得f1和f2变成了链式写法，改善了可读性，而且对多层嵌套的回调函数尤其方便。

### Promise的状态
- pending
- fulfilled
- rejected

### promise构造函数
Js提供原生的Promise构造函数，用来生成Promis实例对象
- resolve
- reject

### Promise.prototype.then()
可以接受两个回调函数

p2.then(console.log, console.error);

成功时候的回调函数console.log,失败时候的回调函数console.error（可以省略）

### 应用
图片加载

### 微任务
Promise的回调属于微任务，

不是正常的异步任务。
正常的异步任务会加入到下一次事件循环，而微任务加入本轮事件循环。

这意味着，.then的回调函数会晚于同步任务，先于正常的异步任务执行

------------------

















# 并发模型和事件循环 | MDN

### 栈
- 函数调用形成了一个栈帧
```JavaScript
function foo(b) {
  var a = 10;
  return a + b + 11;
}

function bar(x) {
  var y = 3;
  return foo(x * y);
}

console.log(bar(7)); // 返回 42

```
当调用`bar`时，创建了第一个帧，其中包含了`bar`的参数和局部变量。当`bar`调用`foo`时，第二个帧被创建，并加入`栈（后进先出）`，帧中包含`foo`的参数和局部变量。

### 堆
对象被分配在一个堆中，即用以表示一大块非结构化的内存区域(堆内存)

### 队列
Js运行时包含了一个待处理的消息队列，每一个消息都关联着一个用以处理这个消息的函数

在事件循环期间的某个时刻，runtime(运行时)从最先进入队列的消息开始处理队列中的消息。


### 事件循环
之所以称为事件循环，是因为它经常被用于类似的如下的方法来实现，

```
while (queue.waitForMessage()) {
  queue.processNextMessage();
}
```
- 执行到完成
每一条消息完整的执行之后，其他消息才会被执行。